========================================
File: backend/main.py
========================================
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from database import engine
import models as models
from routers import auth, folders, files
from fastapi.staticfiles import StaticFiles
from routers import parsing, scoring


app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")

# Create database tables
models.Base.metadata.create_all(bind=engine)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:8501"],  # Streamlit default port
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth.router)
app.include_router(folders.router)
app.include_router(files.router)
app.include_router(parsing.router)
app.include_router(scoring.router)

@app.get("/")
async def root():
    return {"message": "Welcome to the CV Screening API"}

========================================
File: backend/database.py
========================================
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# SQLALCHEMY_DATABASE_URL = "postgresql://user:password@localhost/dbname"
SQLALCHEMY_DATABASE_URL = "postgresql://cvscreening_user:cvscreening_user@localhost/cvscreening"


engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()



========================================
File: backend/models.py
========================================
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Float, Enum, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
import datetime
from sqlalchemy.dialects.postgresql import JSONB

from database import Base
from schemas import Role
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Float, Enum, Boolean, JSON, Text, Date
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
import datetime
from sqlalchemy.dialects.postgresql import JSONB, ARRAY

from database import Base
from schemas import Role


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    point = Column(Integer, default=0)
    phone = Column(String, default="0981234567")
    role = Column(Enum(Role), default=Role.ENDUSER)
    is_activated = Column(Boolean, default=False)
    otp = Column(String, nullable=True)

    folders = relationship("Folder", back_populates="owner")

class Folder(Base):
    __tablename__ = "folders"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))

    owner = relationship("User", back_populates="folders")
    files = relationship("File", back_populates="folder")

class File(Base):
    __tablename__ = "files"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, index=True)
    uploaded_date = Column(DateTime, default=datetime.datetime.utcnow)
    file_type = Column(String)
    size = Column(Float)
    words = Column(Integer)
    number_page = Column(Integer)
    language = Column(String)
    status = Column(String, default="unparsed")
    folder_id = Column(Integer, ForeignKey("folders.id"))
    parsed_data = Column(JSONB)  # Add this line

    folder = relationship("Folder", back_populates="files")

class JobDescription(Base):
    __tablename__ = "job_descriptions"

    id = Column(Integer, primary_key=True, index=True)
    content = Column(String)
    user_id = Column(Integer, ForeignKey("users.id"))

    owner = relationship("User")

class CVInfo(Base):
    __tablename__ = "cv_info"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    
    # Personal Information
    full_name = Column(String)
    industry = Column(String)
    job_title = Column(String)
    level = Column(String)
    phone = Column(String)
    address = Column(String)
    city_province = Column(String)
    country = Column(String)
    date_of_birth = Column(Date)
    gender = Column(String)
    linkedin = Column(String)
    
    summary = Column(Text)
    yoe = Column(Integer)
    skills = Column(ARRAY(String))
    objectives = Column(Text)
    
    user = relationship("User", back_populates="cv_info")
    education = relationship("Education", back_populates="cv_info")
    experience = relationship("Experience", back_populates="cv_info")
    certificates = relationship("Certificate", back_populates="cv_info")
    projects = relationship("Project", back_populates="cv_info")
    awards = relationship("Award", back_populates="cv_info")
    

class Education(Base):
    __tablename__ = "education"

    id = Column(Integer, primary_key=True, index=True)
    cv_info_id = Column(Integer, ForeignKey("cv_info.id"))
    degree = Column(String)
    institution_name = Column(String)
    major = Column(String)
    gpa = Column(String)
    start_time = Column(Date)
    end_time = Column(Date)

    cv_info = relationship("CVInfo", back_populates="education")

class Experience(Base):
    __tablename__ = "experience"

    id = Column(Integer, primary_key=True, index=True)
    cv_info_id = Column(Integer, ForeignKey("cv_info.id"))
    company_name = Column(String)
    job_title = Column(String)
    working_industry = Column(String)
    level = Column(String)
    detailed_working_description = Column(ARRAY(String))
    achievements = Column(ARRAY(String))
    start_time = Column(Date)
    end_time = Column(Date)

    cv_info = relationship("CVInfo", back_populates="experience")

class Certificate(Base):
    __tablename__ = "certificates"

    id = Column(Integer, primary_key=True, index=True)
    cv_info_id = Column(Integer, ForeignKey("cv_info.id"))
    type = Column(String)  # 'language' or 'other'
    language = Column(String, nullable=True)
    certificate_name = Column(String)
    certificate_point_level = Column(String)
    start_time = Column(Date)
    end_time = Column(Date)

    cv_info = relationship("CVInfo", back_populates="certificates")

class Project(Base):
    __tablename__ = "projects"

    id = Column(Integer, primary_key=True, index=True)
    cv_info_id = Column(Integer, ForeignKey("cv_info.id"))
    project_name = Column(String)
    start_time = Column(Date)
    end_time = Column(Date)
    detailed_descriptions = Column(ARRAY(String))

    cv_info = relationship("CVInfo", back_populates="projects")

class Award(Base):
    __tablename__ = "awards"

    id = Column(Integer, primary_key=True, index=True)
    cv_info_id = Column(Integer, ForeignKey("cv_info.id"))
    award_name = Column(String)
    time = Column(Date)
    description = Column(Text)

    cv_info = relationship("CVInfo", back_populates="awards")

# Add this relationship to the User model
User.cv_info = relationship("CVInfo", uselist=False, back_populates="user")




========================================
File: backend/schemas.py
========================================
# File: schemas.py

from pydantic import BaseModel, EmailStr
from typing import Optional
from enum import Enum
from datetime import datetime

class Role(str, Enum):
    ADMIN = "admin"
    ENDUSER = "enduser"

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserCreate(UserBase):
    password: str
    phone: str = "0981234567"

class UserUpdate(BaseModel):
    username: Optional[str] = None
    email: Optional[EmailStr] = None
    password: Optional[str] = None
    phone: Optional[str] = None

class User(UserBase):
    id: int
    role: Role
    is_activated: bool
    point: int

    class Config:
        orm_mode = True

class OTPVerify(BaseModel):
    username: str  # Can be username or email
    otp: str

class UserStatusUpdate(BaseModel):
    is_activated: bool

class FolderBase(BaseModel):
    name: str

class FolderCreate(FolderBase):
    pass

class Folder(FolderBase):
    id: int
    user_id: int

    class Config:
        orm_mode = True

class FolderWithDetails(Folder):
    num_files: int
    size: int

    class Config:
        orm_mode = True

class FileBase(BaseModel):
    filename: str
    file_type: str
    size: float
    words: int
    number_page: int
    language: str
    status: str = "unparsed"

class FileCreate(FileBase):
    folder_id: int

class File(FileBase):
    id: int
    folder_id: int
    uploaded_date: datetime
    parsed_data: Optional[dict] = None
    class Config:
        from_attributes = True
        orm_mode = True

class FileUpdate(BaseModel):
    status: Optional[str] = None

    class Config:
        from_attributes = True
        orm_mode = True

class FileUploadResponse(BaseModel):
    uploaded_files: list[File]
    message: str
    duplicate_files: list[str]
    invalid_files: list[str]

========================================
File: backend/routers/auth.py
========================================
from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta
from typing import List
from schemas import Role
import models, schemas
from database import get_db
import secrets
import smtplib
from email.mime.text import MIMEText

router = APIRouter(prefix="/auth", tags=["auth"])

# JWT and password hashing setup
SECRET_KEY = "85e3eb235be45191af08db4ec8362efc6d6eded15c1d0c0bdc30c1cb36791507"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token")

# Email configuration
EMAIL_HOST = "smtp.gmail.com"
EMAIL_PORT = 587
EMAIL_USER = "tgiang11tn1@gmail.com"
EMAIL_PASSWORD = "xmdg ouhn oqsh psfq"

def create_access_token(data: dict, expires_delta: timedelta or None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def authenticate_user(db: Session, username: str, password: str):
    user = db.query(models.User).filter(
        (models.User.username == username) | (models.User.email == username)
    ).first()
    if not user or not user.is_activated:
        return False
    if not pwd_context.verify(password, user.hashed_password):
        return False
    return user

async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = schemas.TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = db.query(models.User).filter(
        (models.User.username == token_data.username) | (models.User.email == token_data.username)
    ).first()
    if user is None or not user.is_activated:
        raise credentials_exception
    return user

def send_otp_email(email: str, otp: str):
    msg = MIMEText(f"Your OTP for account activation is: {otp}")
    msg['Subject'] = "Account Activation OTP"
    msg['From'] = EMAIL_USER
    msg['To'] = email

    with smtplib.SMTP(EMAIL_HOST, EMAIL_PORT) as server:
        server.starttls()
        server.login(EMAIL_USER, EMAIL_PASSWORD)
        server.send_message(msg)

@router.post("/register", response_model=schemas.User)
def register_user(user: schemas.UserCreate, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    print("==> user: ", user)
    db_user = db.query(models.User).filter(
        (models.User.username == user.username) | (models.User.email == user.email)
    ).first()
    print("==> user: ", user)

    if db_user:
        if db_user.email == user.email:
            detail = "Email already registered"
        elif db_user.username == user.username:
            detail = "Username already registered"
        else:
            detail = "Username or email already registered"
        print(f"==> Error: {detail}")
        raise HTTPException(status_code=400, detail=detail)

    hashed_password = pwd_context.hash(user.password)
    otp = secrets.token_hex(3)  # Generate a 6-character OTP
    db_user = models.User(username=user.username, email=user.email, hashed_password=hashed_password, point=0, role=Role.ENDUSER, is_activated=False, otp=otp)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    background_tasks.add_task(send_otp_email, user.email, otp)
    return db_user

@router.post("/verify-otp", response_model=schemas.User)
def verify_otp(otp_data: schemas.OTPVerify, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(
        (models.User.username == otp_data.username) | (models.User.email == otp_data.username)
    ).first()
    if not user or user.is_activated:
        raise HTTPException(status_code=400, detail="Invalid user or already activated")
    if user.otp != otp_data.otp:
        raise HTTPException(status_code=400, detail="Invalid OTP")
    user.is_activated = True
    user.otp = None
    db.commit()
    db.refresh(user)
    return user

@router.post("/token", response_model=schemas.Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username/email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/users/me/", response_model=schemas.User)
async def read_users_me(current_user: schemas.User = Depends(get_current_user)):
    return current_user

@router.put("/users/me/", response_model=schemas.User)
async def update_user(user: schemas.UserUpdate, current_user: schemas.User = Depends(get_current_user), db: Session = Depends(get_db)):
    if user.username:
        current_user.username = user.username
    if user.email:
        current_user.email = user.email
    if user.password:
        current_user.hashed_password = pwd_context.hash(user.password)
    db.commit()
    db.refresh(current_user)
    return current_user

@router.get("/users/", response_model=List[schemas.User])
async def read_users(skip: int = 0, limit: int = 100, current_user: schemas.User = Depends(get_current_user), db: Session = Depends(get_db)):
    if current_user.role != Role.ADMIN:
        raise HTTPException(status_code=403, detail="Not authorized to view all users")
    users = db.query(models.User).offset(skip).limit(limit).all()
    return users

@router.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(user_id: int, current_user: schemas.User = Depends(get_current_user), db: Session = Depends(get_db)):
    if current_user.role != Role.ADMIN:
        raise HTTPException(status_code=403, detail="Not authorized to delete users")
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    db.delete(user)
    db.commit()
    return {"ok": True}

@router.put("/users/{user_id}/status", response_model=schemas.User)
async def update_user_status(user_id: int, is_activated: bool, current_user: schemas.User = Depends(get_current_user), db: Session = Depends(get_db)):
    if current_user.role != Role.ADMIN:
        raise HTTPException(status_code=403, detail="Not authorized to update user status")
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    user.is_activated = is_activated
    db.commit()
    db.refresh(user)
    return user

# Create admin account
def create_admin(db: Session):
    admin = db.query(models.User).filter(models.User.email == "giang.vo@aivision.vn").first()
    if not admin:
        hashed_password = pwd_context.hash("giang.vo@aivision.vn")
        admin = models.User(username="admin", email="giang.vo@aivision.vn", hashed_password=hashed_password, point=0, role=Role.ADMIN, is_activated=True)
        db.add(admin)
        db.commit()
        db.refresh(admin)
        print("Admin account created successfully")
    else:
        print("Admin account already exists")

# Call this function when your application starts
# For example, in your main.py file:
# from routers.auth import create_admin
# create_admin(Session())







========================================
File: backend/routers/folders.py
========================================
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
import os
import shutil
from pathlib import Path

import models, schemas
from database import get_db
from routers.auth import get_current_user

router = APIRouter(prefix="/folders", tags=["folders"])

UPLOAD_DIR = Path("static/upload_cv")

@router.post("/", response_model=schemas.Folder)
def create_folder(folder: schemas.FolderCreate, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    folder_path = UPLOAD_DIR / str(current_user.id) / folder.name
    if folder_path.exists():
        raise HTTPException(status_code=400, detail="Folder already exists")
    folder_path.mkdir(parents=True, exist_ok=True)
    
    db_folder = models.Folder(**folder.dict(), user_id=current_user.id)
    db.add(db_folder)
    db.commit()
    db.refresh(db_folder)
    return db_folder

@router.get("/", response_model=List[schemas.FolderWithDetails])
def read_folders(skip: int = 0, limit: int = 100, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    folders = db.query(models.Folder).filter(models.Folder.user_id == current_user.id).offset(skip).limit(limit).all()
    
    folder_details = []
    for folder in folders:
        folder_path = UPLOAD_DIR / str(current_user.id) / folder.name
        num_files = len(list(folder_path.glob('*')))
        size = sum(f.stat().st_size for f in folder_path.glob('**/*') if f.is_file())
        
        folder_details.append(schemas.FolderWithDetails(
            **folder.__dict__,
            num_files=num_files,
            size=size
        ))
    
    return folder_details

@router.get("/{folder_id}", response_model=schemas.FolderWithDetails)
def read_folder(folder_id: int, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    folder = db.query(models.Folder).filter(models.Folder.id == folder_id, models.Folder.user_id == current_user.id).first()
    if folder is None:
        raise HTTPException(status_code=404, detail="Folder not found")
    
    folder_path = UPLOAD_DIR / str(current_user.id) / folder.name
    num_files = len(list(folder_path.glob('*')))
    size = sum(f.stat().st_size for f in folder_path.glob('**/*') if f.is_file())
    
    return schemas.FolderWithDetails(
        **folder.__dict__,
        num_files=num_files,
        size=size
    )

@router.put("/{folder_id}", response_model=schemas.Folder)
def update_folder(folder_id: int, folder: schemas.FolderCreate, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    db_folder = db.query(models.Folder).filter(models.Folder.id == folder_id, models.Folder.user_id == current_user.id).first()
    if db_folder is None:
        raise HTTPException(status_code=404, detail="Folder not found")
    
    old_path = UPLOAD_DIR / str(current_user.id) / db_folder.name
    new_path = UPLOAD_DIR / str(current_user.id) / folder.name
    
    if old_path != new_path:
        if new_path.exists():
            raise HTTPException(status_code=400, detail="Folder with new name already exists")
        old_path.rename(new_path)
    
    db_folder.name = folder.name
    db.commit()
    db.refresh(db_folder)
    return db_folder

@router.delete("/{folder_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_folder(folder_id: int, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    db_folder = db.query(models.Folder).filter(models.Folder.id == folder_id, models.Folder.user_id == current_user.id).first()
    if db_folder is None:
        raise HTTPException(status_code=404, detail="Folder not found")
    
    folder_path = UPLOAD_DIR / str(current_user.id) / db_folder.name
    if folder_path.exists():
        shutil.rmtree(folder_path)
    
    # Delete all files associated with this folder
    db.query(models.File).filter(models.File.folder_id == folder_id).delete()
    
    db.delete(db_folder)
    db.commit()
    return {"ok": True}

========================================
File: backend/routers/files.py
========================================
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Query
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
from typing import List, Optional
from pathlib import Path
import shutil
import datetime
import magic
import PyPDF2
import os

import models, schemas
from database import get_db
from routers.auth import get_current_user

router = APIRouter(prefix="/files", tags=["files"])

UPLOAD_DIR = Path("static/upload_cv")
MAX_FILES_PER_UPLOAD = 200
MAX_FILES_PER_FOLDER = 100000
ALLOWED_EXTENSIONS = {'.pdf'}

def get_file_details(file_path: Path):
    mime = magic.Magic(mime=True)
    file_type = mime.from_file(str(file_path))
    size = file_path.stat().st_size
    words = 0
    number_page = 1
    language = "unknown"

    if file_path.suffix.lower() == '.pdf':
        with open(file_path, 'rb') as f:
            pdf_reader = PyPDF2.PdfReader(f)
            number_page = len(pdf_reader.pages)
            text = ""
            for page in pdf_reader.pages:
                text += page.extract_text()
            words = len(text.split())
            language = "English"  # You might want to implement actual language detection here

    return file_type, size, words, number_page, language

@router.post("/", response_model=schemas.FileUploadResponse)
async def create_files(
    files: List[UploadFile] = File(...),
    folder_id: int = Query(...),
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(get_current_user)
):
    folder = db.query(models.Folder).filter(models.Folder.id == folder_id, models.Folder.user_id == current_user.id).first()
    if not folder:
        raise HTTPException(status_code=404, detail="Folder not found")

    folder_path = UPLOAD_DIR / str(current_user.id) / folder.name
    if not folder_path.exists():
        raise HTTPException(status_code=404, detail="Folder not found in filesystem")

    existing_files = len(list(folder_path.glob('*')))
    if existing_files + len(files) > MAX_FILES_PER_FOLDER:
        raise HTTPException(status_code=400, detail=f"Folder would exceed the maximum limit of {MAX_FILES_PER_FOLDER} files")

    if len(files) > MAX_FILES_PER_UPLOAD:
        raise HTTPException(status_code=400, detail=f"Maximum {MAX_FILES_PER_UPLOAD} files can be uploaded at once")

    uploaded_files = []
    duplicate_files = []
    invalid_files = []
    for file in files:
        file_extension = Path(file.filename).suffix.lower()
        if file_extension not in ALLOWED_EXTENSIONS:
            invalid_files.append(file.filename)
            continue

        file_path = folder_path / file.filename
        if file_path.exists():
            duplicate_files.append(file.filename)
            continue

        with file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        file_type, size, words, number_page, language = get_file_details(file_path)

        db_file = models.File(
            filename=file.filename,
            file_type=file_type,
            size=size,
            words=words,
            number_page=number_page,
            language=language,
            folder_id=folder_id,
            status="unparsed",
            uploaded_date=datetime.datetime.utcnow()
        )
        db.add(db_file)
        db.commit()
        db.refresh(db_file)
        uploaded_files.append(schemas.File.from_orm(db_file))

    response = schemas.FileUploadResponse(
        uploaded_files=uploaded_files,
        message="File upload completed",
        duplicate_files=duplicate_files,
        invalid_files=invalid_files
    )

    if not uploaded_files and (duplicate_files or invalid_files):
        raise HTTPException(status_code=400, detail=response.dict())

    return response

@router.get("/", response_model=List[schemas.File])
def read_files(
    folder_id: int,
    skip: int = 0,
    limit: int = 100,
    sort_by: Optional[str] = None,
    sort_order: Optional[str] = "asc",
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(get_current_user)
):
    query = db.query(models.File).filter(models.File.folder_id == folder_id)
    
    folder = db.query(models.Folder).filter(models.Folder.id == folder_id, models.Folder.user_id == current_user.id).first()
    if not folder:
        raise HTTPException(status_code=404, detail="Folder not found")

    if sort_by:
        if sort_order == "desc":
            query = query.order_by(getattr(models.File, sort_by).desc())
        else:
            query = query.order_by(getattr(models.File, sort_by))

    files = query.offset(skip).limit(limit).all()
    return files

@router.get("/{file_id}", response_model=schemas.File)
def read_file(file_id: int, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    file = db.query(models.File).join(models.Folder).filter(models.File.id == file_id, models.Folder.user_id == current_user.id).first()
    if file is None:
        raise HTTPException(status_code=404, detail="File not found")
    return file

@router.get("/{file_id}/download")
def download_file(file_id: int, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    file = db.query(models.File).join(models.Folder).filter(models.File.id == file_id, models.Folder.user_id == current_user.id).first()
    if file is None:
        raise HTTPException(status_code=404, detail="File not found")
    
    file_path = UPLOAD_DIR / str(current_user.id) / file.folder.name / file.filename
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="File not found in filesystem")
    
    return FileResponse(file_path, filename=file.filename, media_type='application/pdf')

@router.put("/{file_id}", response_model=schemas.File)
def update_file(file_id: int, file: schemas.FileUpdate, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    db_file = db.query(models.File).join(models.Folder).filter(models.File.id == file_id, models.Folder.user_id == current_user.id).first()
    if db_file is None:
        raise HTTPException(status_code=404, detail="File not found")
    for key, value in file.dict(exclude_unset=True).items():
        setattr(db_file, key, value)
    db.commit()
    db.refresh(db_file)
    return db_file

@router.delete("/{file_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_file(file_id: int, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    db_file = db.query(models.File).join(models.Folder).filter(models.File.id == file_id, models.Folder.user_id == current_user.id).first()
    if db_file is None:
        raise HTTPException(status_code=404, detail="File not found")
    
    file_path = UPLOAD_DIR / str(current_user.id) / db_file.folder.name / db_file.filename
    if file_path.exists():
        os.remove(file_path)
    
    db.delete(db_file)
    db.commit()
    return {"ok": True}

@router.post("/{file_id}/parse", response_model=schemas.File)
def parse_file(file_id: int, db: Session = Depends(get_db), current_user: schemas.User = Depends(get_current_user)):
    db_file = db.query(models.File).join(models.Folder).filter(models.File.id == file_id, models.Folder.user_id == current_user.id).first()
    if db_file is None:
        raise HTTPException(status_code=404, detail="File not found")
    
    # Here you would implement the parsing logic
    # For now, we'll just update the status
    db_file.status = "parsed"
    db.commit()
    db.refresh(db_file)
    return db_file

========================================
File: frontend/app.py
========================================
import streamlit as st
import requests
import json
import pandas as pd
import base64
from io import BytesIO
from streamlit_option_menu import option_menu
import plotly.express as px

API_URL = "http://localhost:8000"  # Adjust this to your FastAPI backend URL

def set_page_config():
    st.set_page_config(page_title="CV Screening", page_icon="üìÑ", layout="wide")
    st.markdown("""
        <style>
        .main {
            padding-top: 2rem;
        }
        .stButton>button {
            width: 100%;
        }
        .stDataFrame {
            font-size: 14px;
        }
        </style>
        """, unsafe_allow_html=True)

def login():
    st.title("CV Screening - Login")
    col1, col2, col3 = st.columns([1,2,1])
    with col2:
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")
        if st.button("Login", key="login_button"):
            response = requests.post(f"{API_URL}/auth/token", data={"username": username, "password": password})
            if response.status_code == 200:
                st.session_state.token = response.json()["access_token"]
                st.success("Logged in successfully!")
                st.rerun()
            else:
                st.error("Invalid username or password")

def list_folders():
    st.title("CV Screening - Your Candidates")
    response = requests.get(f"{API_URL}/folders", headers={"Authorization": f"Bearer {st.session_state.token}"})
    if response.status_code == 200:
        folders = response.json()
        col1, col2 = st.columns([3, 1])
        with col1:
            for folder in folders:
                if st.button(f"üìÅ {folder['name']} ({folder['num_files']} files, {folder['size']} bytes)", key=f"folder_{folder['id']}"):
                    st.session_state.current_folder = folder['id']
                    st.session_state.current_folder_name = folder['name']
                    st.rerun()
        with col2:
            create_folder()

def create_folder():
    st.subheader("Create New Folder")
    folder_name = st.text_input("Folder Name")
    if st.button("Create Folder"):
        response = requests.post(f"{API_URL}/folders", json={"name": folder_name}, headers={"Authorization": f"Bearer {st.session_state.token}"})
        if response.status_code == 200:
            st.success("Folder created successfully!")
            st.rerun()
        else:
            st.error("Failed to create folder")

def upload_files(folder_id):
    st.subheader("Upload Files")
    uploaded_files = st.file_uploader("Choose PDF files", accept_multiple_files=True, type=['pdf'])
    if uploaded_files and st.button("Upload Files"):
        files = [("files", file) for file in uploaded_files]
        with st.spinner("Uploading files..."):
            response = requests.post(
                f"{API_URL}/files?folder_id={folder_id}",
                files=files,
                headers={"Authorization": f"Bearer {st.session_state.token}"}
            )
        
        if response.status_code == 200:
            result = response.json()
            uploaded_files = [file['filename'] for file in result['uploaded_files']]
            duplicate_files = result['duplicate_files']
            invalid_files = result['invalid_files']
            
            if uploaded_files:
                st.success(f"Successfully uploaded: {', '.join(uploaded_files)}")
            if duplicate_files:
                st.warning(f"Duplicate files not uploaded: {', '.join(duplicate_files)}")
            if invalid_files:
                st.error(f"Invalid files not uploaded: {', '.join(invalid_files)}")
            
            if uploaded_files:
                st.rerun()
        else:
            st.error(f"Failed to upload files: {response.text}")

def delete_files(file_ids):
    for file_id in file_ids:
        response = requests.delete(
            f"{API_URL}/files/{file_id}",
            headers={"Authorization": f"Bearer {st.session_state.token}"}
        )
        if response.status_code != 204:
            st.error(f"Failed to delete file with ID {file_id}")
            return
    
    st.success("Successfully deleted files!")
    st.rerun()

import streamlit as st
import requests
import json
import pandas as pd
import base64
from io import BytesIO
from streamlit_option_menu import option_menu
import plotly.express as px


import streamlit as st
import requests
import json
import pandas as pd
import base64
from io import BytesIO
from streamlit_option_menu import option_menu
import plotly.express as px


def view_file(file_id, filename):
    response = requests.get(
        f"{API_URL}/files/{file_id}/download",
        headers={"Authorization": f"Bearer {st.session_state.token}"},
        stream=True
    )
    if response.status_code == 200:
        pdf_content = response.content
        base64_pdf = base64.b64encode(pdf_content).decode('utf-8')
        pdf_display = f'<iframe src="data:application/pdf;base64,{base64_pdf}" width="100%" height="600" type="application/pdf"></iframe>'
        return pdf_display
    else:
        return None

def list_files(folder_id):
    response = requests.get(f"{API_URL}/files?folder_id={folder_id}", headers={"Authorization": f"Bearer {st.session_state.token}"})
    if response.status_code == 200:
        files = response.json()
        if files:
            df = pd.DataFrame(files)
            df['Select'] = False
            columns = ['Select', 'id', 'filename'] + [col for col in df.columns if col not in ['Select', 'id', 'filename']]
            df = df[columns]
            
            st.subheader("File List")
            edited_df = st.data_editor(
                df,
                hide_index=True,
                column_config={
                    "Select": st.column_config.CheckboxColumn(required=True),
                    "filename": st.column_config.TextColumn(
                        "Filename",
                        help="File name",
                        required=True,
                    ),
                },
                disabled=df.columns.drop(['Select']),
                key="file_table"
            )
            
            selected_file_ids = edited_df[edited_df['Select']]['id'].tolist()
            
            if st.button("Delete Selected Files"):
                if selected_file_ids:
                    delete_files(selected_file_ids)
                else:
                    st.warning("No files selected for deletion.")
            
            # File viewing section
            st.subheader("View Files")
            col1, col2 = st.columns([1, 3])
            
            with col1:
                st.subheader("File Names")
                for index, row in edited_df.iterrows():
                    if st.button(f"{row['filename']}", key=f"view_{row['id']}"):
                        st.session_state.current_file = row['id']
                        st.session_state.current_filename = row['filename']
                        st.rerun()
            
            with col2:
                st.subheader("File Preview")
                if 'current_file' in st.session_state:
                    pdf_display = view_file(st.session_state.current_file, st.session_state.current_filename)
                    if pdf_display:
                        st.markdown(pdf_display, unsafe_allow_html=True)
                    else:
                        st.error("Failed to load the file preview.")
                else:
                    st.info("Select a file to preview.")
        else:
            st.info("No files in this folder yet.")
    else:
        st.error("Failed to fetch files")

def parse_folder(folder_id):
    st.subheader("AI Parsing")
    if st.button("Start Parsing"):
        response = requests.post(
            f"{API_URL}/parsing/{folder_id}/parse",
            headers={"Authorization": f"Bearer {st.session_state.token}"}
        )
        if response.status_code == 200:
            st.success("Parsing started. Check status for updates.")
        else:
            st.error("Failed to start parsing")

def check_parsing_status(folder_id):
    response = requests.get(
        f"{API_URL}/parsing/{folder_id}/status",
        headers={"Authorization": f"Bearer {st.session_state.token}"}
    )
    if response.status_code == 200:
        files = response.json()
        statuses = [file['status'] for file in files]
        total = len(statuses)
        parsed = statuses.count("parsed")
        parsing = statuses.count("parsing")
        unparsed = statuses.count("unparsed")
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Total files", total)
            st.metric("Parsed", parsed)
            st.metric("Parsing", parsing)
            st.metric("Unparsed", unparsed)
        
        with col2:
            fig = px.pie(values=[parsed, parsing, unparsed], names=['Parsed', 'Parsing', 'Unparsed'], title='Parsing Status')
            st.plotly_chart(fig, use_container_width=True)
        
        if parsed == total:
            st.success("All files parsed successfully!")
            if st.button("Download Parsed Data"):
                download_parsed_data(folder_id)
    else:
        st.error("Failed to fetch parsing status")

def download_parsed_data(folder_id):
    response = requests.get(
        f"{API_URL}/parsing/{folder_id}/download",
        headers={"Authorization": f"Bearer {st.session_state.token}"}
    )
    if response.status_code == 200:
        st.download_button(
            label="Download Excel",
            data=response.content,
            file_name=f"parsed_data_{st.session_state.current_folder_name}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.error("Failed to download parsed data")

def cv_scoring(folder_id):
    st.subheader("CV Scoring")
    score_method = st.radio("Choose job description input method:", ("Upload PDF", "Type or Paste"))
    
    if score_method == "Upload PDF":
        uploaded_file = st.file_uploader("Upload job description PDF", type=['pdf'])
        if uploaded_file:
            files = {"job_description_file": uploaded_file}
            data = {}
        else:
            st.warning("Please upload a PDF file")
            return
    else:
        job_description = st.text_area("Enter job description")
        if job_description:
            files = None
            data = {"job_description": job_description}
        else:
            st.warning("Please enter a job description")
            return
    
    if st.button("Score CVs"):
        response = requests.post(
            f"{API_URL}/scoring/{folder_id}/score",
            headers={"Authorization": f"Bearer {st.session_state.token}"},
            files=files,
            data=data
        )
        if response.status_code == 200:
            scores = response.json()
            df = pd.DataFrame(scores)
            st.dataframe(df)
            
            fig = px.bar(df, x='filename', y='score', title='CV Scores')
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.error("Failed to score CVs")

def main():
    set_page_config()
    
    if "token" not in st.session_state:
        login()
    else:
        with st.sidebar:
            st.title("CV Screening")
            menu_choice = option_menu(
                "Main Menu",
                ["Folders", "Upload", "Files", "AI Parsing", "CV Scoring"],
                icons=['folder', 'cloud-upload', 'file-earmark', 'cpu', 'star'],
                menu_icon="cast",
                default_index=0,
            )
        
        if menu_choice == "Folders" or "current_folder" not in st.session_state:
            list_folders()
        elif "current_folder" in st.session_state:
            st.title(f"CV Screening - Folder: {st.session_state.current_folder_name}")
            
            if menu_choice == "Upload":
                upload_files(st.session_state.current_folder)
            elif menu_choice == "Files":
                list_files(st.session_state.current_folder)
            elif menu_choice == "AI Parsing":
                parse_folder(st.session_state.current_folder)
                check_parsing_status(st.session_state.current_folder)
            elif menu_choice == "CV Scoring":
                cv_scoring(st.session_state.current_folder)

if __name__ == "__main__":
    main()

========================================
File: requirements.txt
========================================


Script completed.
